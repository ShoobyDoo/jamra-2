import { build } from "esbuild";
import type { Message } from "esbuild";
import path from "node:path";
import { DomainError } from "../../../shared/errors.js";

/**
 * Result of TypeScript/JavaScript compilation
 */
export interface CompilationResult {
  success: boolean;
  outputCode?: string; // Compiled JavaScript code
  errors: string[]; // Compilation errors
  warnings: string[]; // Compilation warnings
}

/**
 * Compiles TypeScript and JavaScript source code using esbuild
 */
export class ExtensionCompiler {
  /**
   * Compile source code to JavaScript
   * @param sourceCode - TypeScript or JavaScript source code
   * @param entrypoint - Entry file name (e.g., "src/index.ts")
   * @param extensionId - Extension identifier for logging
   * @returns Compilation result
   */
  async compile(
    sourceCode: string,
    entrypoint: string,
    _extensionId: string,
  ): Promise<CompilationResult> {
    try {
      // Determine loader based on file extension
      const ext = path.extname(entrypoint).toLowerCase();
      const loader = this.getLoader(ext);

      const buildResult = await build({
        stdin: {
          contents: sourceCode,
          loader,
          resolveDir: process.cwd(),
          sourcefile: entrypoint,
        },
        bundle: true,
        platform: "node",
        format: "cjs",
        target: "es2020",
        sourcemap: "inline",
        write: false,
        define: {
          "process.env.NODE_ENV":
            JSON.stringify(process.env.NODE_ENV ?? "production"),
        },
        logLevel: "silent",
        external: [], // Bundle everything
        metafile: false,
      });

      const outputFile = buildResult.outputFiles?.[0];
      if (!outputFile) {
        return {
          success: false,
          errors: ["No output generated by esbuild"],
          warnings: [],
        };
      }

      // Collect errors and warnings
      const errors = buildResult.errors.map((err) => this.formatError(err));
      const warnings = buildResult.warnings.map((warn) =>
        this.formatError(warn),
      );

      return {
        success: errors.length === 0,
        outputCode: outputFile.text,
        errors,
        warnings,
      };
    } catch (error) {
      if (error instanceof Error) {
        return {
          success: false,
          errors: [`Compilation failed: ${error.message}`],
          warnings: [],
        };
      }

      return {
        success: false,
        errors: ["Compilation failed: Unknown error"],
        warnings: [],
      };
    }
  }

  /**
   * Compile extension from source files map
   * @param sourceFiles - Map of file paths to file contents
   * @param entrypoint - Entry file path
   * @param extensionId - Extension identifier
   * @returns Compilation result
   */
  async compileFromFiles(
    sourceFiles: Map<string, string>,
    entrypoint: string,
    extensionId: string,
  ): Promise<CompilationResult> {
    // Get the entrypoint source code
    const entrypointCode = sourceFiles.get(entrypoint);

    if (!entrypointCode) {
      throw new DomainError(
        `Entrypoint file not found in source files: ${entrypoint}`,
      );
    }

    // For now, compile only the entrypoint
    // TODO: In the future, we could support importing other files
    return this.compile(entrypointCode, entrypoint, extensionId);
  }

  /**
   * Get esbuild loader for file extension
   */
  private getLoader(
    ext: string,
  ): "ts" | "tsx" | "js" | "jsx" | "json" | "text" {
    switch (ext) {
      case ".ts":
        return "ts";
      case ".tsx":
        return "tsx";
      case ".jsx":
        return "jsx";
      case ".js":
      case ".mjs":
      case ".cjs":
        return "js";
      case ".json":
        return "json";
      default:
        return "js"; // Default to JavaScript
    }
  }

  /**
   * Format esbuild error/warning message
   */
  private formatError(message: Message): string {
    const location = message.location
      ? `${message.location.file}:${message.location.line}:${message.location.column}`
      : "";
    const text = message.text || "Unknown error";

    return location ? `${location}: ${text}` : text;
  }
}

/**
 * Factory function to create ExtensionCompiler
 */
export const createExtensionCompiler = (): ExtensionCompiler => {
  return new ExtensionCompiler();
};
